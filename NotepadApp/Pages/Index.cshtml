@page
@using NotepadApp.Models
@namespace NotepadApp.Pages
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers

@{
    ViewData["Title"] = "Real-Time Sticky Notes";
}

<div class="jumbotron text-center">
    <div class="container">
        <a href="/" class="lang-logo">
            <img src="/lang-logo.png">
        </a>
        <h1>Realtime Sticky Notes with SignalR</h1>
        <p>This sample .NET Razor application is deployed to Heroku. It uses SignalR in .NET, leveraging recent HTTP/2 support on Heroku to optimize network traffic. The architecture can be easily scaled using Heroku Dyno scaling and the Heroku Key-Value Store.</p>
    </div>
</div>

<div class="note-container" id="noteContainer">
    <svg id="connectionsCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0;"></svg>
    <button class="add-note-btn" onclick="createNewNote('#FFD700')">+</button>
    <button class="add-note-btn color-btn" style="background-color: #F44336;" onclick="createNewNote('#F44336')">R</button>
    <button class="add-note-btn color-btn" style="background-color: #FFD700;" onclick="createNewNote('#FFD700')">Y</button>
    <button class="add-note-btn color-btn" style="background-color: #4CAF50;" onclick="createNewNote('#4CAF50')">G</button>
    <button id="toggleConnectModeBtn" class="control-btn" style="position: fixed; bottom: 30px; right: 310px; z-index: 1000;">Connect Notes</button>
</div>

@section Styles {
    <style>
        /* Navigation styles */
        .navbar {
            background-color: #1a1a1a !important;
            padding: 1rem 0;
        }

        .navbar-brand {
            color: #fff !important;
            font-weight: bold;
        }

        .navbar-dark .navbar-nav .nav-link {
            color: rgba(255,255,255,.8) !important;
        }

        .navbar-dark .navbar-nav .nav-link:hover {
            color: #fff !important;
        }

        .navbar-dark .navbar-toggler {
            border-color: rgba(255,255,255,.1);
        }

        .navbar-dark .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba(255, 255, 255, 0.8)' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }

        /* Jumbotron styles */
        .jumbotron {
            background: #532F8C;
            color: white;
            padding: 2rem 1rem;
            margin-bottom: 2rem;
        }

        .jumbotron .btn-primary {
            background: #845ac7;
            border-color: #845ac7;
        }

        .jumbotron .btn-primary:hover {
            background: #7646c1;
        }

        .jumbotron p {
            color: #d9ccee;
            max-width: 75%;
            margin: 1em auto 2em;
        }

        .navbar + .jumbotron {
            margin-top: -20px;
        }

        .jumbotron .lang-logo {
            display: block;
            background: #B01302;
            border-radius: 50%;
            overflow: hidden;
            width: 100px;
            height: 100px;
            margin: auto;
            border: 2px solid white;
        }

        .jumbotron .lang-logo img {
            max-width: 100%;
        }

        /* Footer styles */
        .footer {
            background-color: #2c3e50;
            color: rgba(255,255,255,.8);
            padding: 1rem 0;
        }

        .footer a {
            color: #fff;
            text-decoration: none;
        }

        .footer a:hover {
            color: #fff;
            text-decoration: underline;
        }

        /* Note container styles */
        .note-container {
            position: relative;
            min-height: 100vh;
            background: #f0f0f0;
            padding: 20px;
        }

        .note {
            position: absolute;
            width: 250px;
            min-height: 250px;
            padding: 15px;
            margin: 10px;
            background: #ffd700;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
            border-radius: 3px;
            z-index: 1;
        }

        .note:hover {
            transform: scale(1.02);
            z-index: 1000;
        }

        .note-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 5px;
        }

        .drag-handle {
            cursor: move;
            padding: 0 8px;
            color: rgba(0,0,0,0.3);
            font-size: 16px;
            user-select: none;
        }

        .drag-handle:hover {
            color: rgba(0,0,0,0.5);
        }

        .note-title {
            font-weight: bold;
            flex-grow: 1;
            cursor: text;
            outline: none;
            user-select: text;
        }

        .note-title:focus {
            outline: none;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .note-content {
            min-height: 150px;
            outline: none;
            cursor: text;
            user-select: text;
        }

        .note-content:focus {
            outline: none;
        }

        .note-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }

        .close-btn {
            background: none;
            border: none;
            color: #000;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .close-btn:hover {
            opacity: 1;
        }

        .add-note-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #007bff;
            color: white;
            border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s;
            z-index: 1000;
        }

        .add-note-btn:hover {
            transform: scale(1.1);
        }

        .color-btn {
            /* Adjust positioning if they overlap or look odd */
            /* Example: move them up slightly from the default '+' button position */
            bottom: 100px; /* Default '+' is at 30px, so this is 70px above */
        }
        /* Position the color buttons relative to the main '+' button */
        .color-btn:nth-of-type(2) { /* Red */
            right: 100px; /* Further to the left */
            bottom: 30px;
        }
        .color-btn:nth-of-type(3) { /* Yellow */
            right: 170px;
            bottom: 30px;
        }
        .color-btn:nth-of-type(4) { /* Green */
            right: 240px;
            bottom: 30px;
        }

        .note.dragging {
            z-index: 1000;
            opacity: 0.8;
        }

        /* Styles for connection lines */
        .connection-line {
            stroke: #555;
            stroke-width: 2px;
            pointer-events: auto; /* Allow clicks on lines for deletion */
            cursor: pointer;
        }

        .connection-line:hover {
            stroke: #ff0000; /* Highlight on hover */
        }

        .note.selected-for-connection {
            border: 2px dashed #007bff;
            box-shadow: 0 0 10px rgba(0,123,255,0.5);
        }

        .control-btn {
            padding: 10px 15px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .control-btn:hover {
            background-color: #5a6268;
        }
    </style>
}

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <script>
        let connection;
        let notes = new Map();
        let isDragging = false;

        // Variables for note connections
        let noteConnections = new Map(); // Stores connection objects by their ID
        let isConnectMode = false;
        let firstNoteSelectedForConnection = null;
        let connectionsCanvas; // Will hold the SVG element

        async function initializeSignalR() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/noteHub")
                .withAutomaticReconnect()
                .build();

            connection.on("ReceiveNote", (note) => {
                addNoteToUI(note);
            });

            connection.on("UpdateNote", (note) => {
                updateNoteInUI(note);
            });

            connection.on("DeleteNote", (noteId) => {
                deleteNoteFromUI(noteId);
            });

            connection.on("MoveNote", (noteId, x, y) => {
                moveNoteInUI(noteId, x, y);
            });

            // Handler for receiving a new connection
            connection.on("ReceiveNoteConnection", (connectionData) => {
                console.log("ReceiveNoteConnection", connectionData);
                if (!noteConnections.has(connectionData.id)) {
                    noteConnections.set(connectionData.id, connectionData);
                    drawConnection(connectionData);
                }
            });

            // Handler for removing a connection
            connection.on("RemoveNoteConnection", (connectionId) => {
                console.log("RemoveNoteConnection", connectionId);
                if (noteConnections.has(connectionId)) {
                    noteConnections.delete(connectionId);
                    removeConnectionLine(connectionId);
                }
            });

            try {
                await connection.start();
                console.log("SignalR Connected!");
            } catch (err) {
                console.error("SignalR Connection Error: ", err);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            connectionsCanvas = document.getElementById('connectionsCanvas');
            initializeSignalR();
            setupConnectModeButton();
        });

        function createNewNote(colorHex) {
            if (!connection) {
                console.error("SignalR connection not initialized");
                return;
            }
            const note = {
                title: "New Note",
                content: "",
                color: colorHex || "#ffd700", // Use provided color or default to yellow
                positionX: Math.random() * (window.innerWidth - 300),
                positionY: Math.random() * (window.innerHeight - 300)
            };
            connection.invoke("AddNote", note);
        }

        function addNoteToUI(note) {
            const noteElement = document.createElement("div");
            noteElement.className = "note";
            noteElement.id = note.id;
            noteElement.style.left = note.positionX + "px";
            noteElement.style.top = note.positionY + "px";
            noteElement.style.backgroundColor = note.color;

            // Add click listener for connection mode
            noteElement.addEventListener('click', () => handleNoteClickForConnection(note.id));

            noteElement.innerHTML = `
                <div class="note-actions">
                    <button class="close-btn" onclick="deleteNote(${note.id})">×</button>
                </div>
                <div class="note-header">
                    <div class="drag-handle">⋮⋮</div>
                    <div class="note-title" contenteditable="true" onblur="updateNoteTitle(${note.id}, this.textContent)">${note.title}</div>
                </div>
                <div class="note-content" contenteditable="true" onblur="updateNoteContent(${note.id}, this.textContent)">${note.content}</div>
            `;
            makeDraggable(noteElement);
            document.getElementById("noteContainer").appendChild(noteElement);
            notes.set(note.id, note);
        }

        function updateNoteInUI(note) {
            const noteElement = document.getElementById(note.id);
            if (noteElement) {
                noteElement.querySelector(".note-title").textContent = note.title;
                noteElement.querySelector(".note-content").textContent = note.content;
                noteElement.style.backgroundColor = note.color;
                notes.set(note.id, note);
            }
        }

        function deleteNoteFromUI(noteId) {
            const noteElement = document.getElementById(noteId);
            if (noteElement) {
                noteElement.remove();
                notes.delete(noteId);
                // Connections are removed via SignalR message "RemoveNoteConnection"
                // which will trigger removeConnectionLine if the note deletion caused cascade delete in DB.
            }
        }

        function moveNoteInUI(noteId, x, y) {
            const noteElement = document.getElementById(noteId);
            if (noteElement) {
                noteElement.style.left = x + "px";
                noteElement.style.top = y + "px";
                noteElement.style.transform = "none"; // Reset transform if it was applied during drag initiation
                
                const note = notes.get(noteId);
                if (note) {
                    note.positionX = x;
                    note.positionY = y;
                }
                updateConnectionLinesForNote(noteId); // Update lines when a note moves
            }
        }

        function updateNoteTitle(noteId, title) {
            const note = notes.get(noteId);
            if (note) {
                note.title = title;
                note.updatedAt = new Date();
                connection.invoke("UpdateNote", note);
            }
        }

        function updateNoteContent(noteId, content) {
            const note = notes.get(noteId);
            if (note) {
                note.content = content;
                note.updatedAt = new Date();
                connection.invoke("UpdateNote", note);
            }
        }

        function deleteNote(noteId) {
            connection.invoke("DeleteNote", parseInt(noteId));
        }

        function makeDraggable(element) {
            let startX, startY, initialX, initialY;
            let originalLeft, originalTop;

            const dragHandle = element.querySelector('.drag-handle');
            dragHandle.onmousedown = dragStart;

            function dragStart(e) {
                initialX = e.clientX - element.offsetLeft;
                initialY = e.clientY - element.offsetTop;
                originalLeft = element.offsetLeft;
                originalTop = element.offsetTop;

                if (e.target === dragHandle) {
                    element.classList.add('dragging');
                    document.onmousemove = drag;
                    document.onmouseup = dragEnd;
                }
            }

            function drag(e) {
                if (element.classList.contains('dragging')) {
                    e.preventDefault();
                    startX = e.clientX - initialX;
                    startY = e.clientY - initialY;

                    element.style.left = startX + "px";
                    element.style.top = startY + "px";

                    // Update connection lines in real-time during drag
                    const noteId = parseInt(element.id);
                    if (!isNaN(noteId)) {
                        updateConnectionLinesForNote(noteId);
                    }
                }
            }

            function dragEnd(e) {
                if (element.classList.contains('dragging')) {
                    element.classList.remove('dragging');
                    document.onmousemove = null;
                    document.onmouseup = null;

                    const noteId = parseInt(element.id);
                    connection.invoke("MoveNote", noteId, startX, startY);
                }
            }
        }

        // --- Note Connection Drawing Functions ---

        function drawConnection(connectionData) {
            if (!connectionsCanvas) return;

            const sourceNoteEl = document.getElementById(connectionData.sourceNoteId);
            const targetNoteEl = document.getElementById(connectionData.targetNoteId);

            if (!sourceNoteEl || !targetNoteEl) {
                console.warn("Cannot draw connection, source or target note element not found:", connectionData);
                return;
            }

            const lineId = `line-${connectionData.id}`;
            let line = document.getElementById(lineId);
            if (!line) {
                line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("id", lineId);
                line.setAttribute("class", "connection-line");
                line.addEventListener('click', () => {
                    if (confirm('Delete this connection?')) {
                        console.log(`Attempting to disconnect connection ID: ${connectionData.id}`);
                        connection.invoke("DisconnectNotes", connectionData.id);
                    }
                });
                connectionsCanvas.appendChild(line);
            }
            
            const containerRect = document.getElementById('noteContainer').getBoundingClientRect();

            // Calculate center points first
            const rectSourceInitial = sourceNoteEl.getBoundingClientRect();
            const rectTargetInitial = targetNoteEl.getBoundingClientRect();

            const sourceCenter = {
                x: rectSourceInitial.left - containerRect.left + rectSourceInitial.width / 2,
                y: rectSourceInitial.top - containerRect.top + rectSourceInitial.height / 2
            };
            const targetCenter = {
                x: rectTargetInitial.left - containerRect.left + rectTargetInitial.width / 2,
                y: rectTargetInitial.top - containerRect.top + rectTargetInitial.height / 2
            };

            // Get intersection points with note edges
            const startPoint = getEdgeIntersectionPoint(sourceNoteEl, targetCenter, containerRect);
            const endPoint = getEdgeIntersectionPoint(targetNoteEl, sourceCenter, containerRect);
            
            if (!startPoint || !endPoint) {
                console.warn("Could not calculate intersection points for connection:", connectionData);
                 // Fallback to center if calculation fails, or hide line
                line.setAttribute("x1", sourceCenter.x);
                line.setAttribute("y1", sourceCenter.y);
                line.setAttribute("x2", targetCenter.x);
                line.setAttribute("y2", targetCenter.y);
                return;
            }

            line.setAttribute("x1", startPoint.x);
            line.setAttribute("y1", startPoint.y);
            line.setAttribute("x2", endPoint.x);
            line.setAttribute("y2", endPoint.y);
        }

        function getEdgeIntersectionPoint(noteElement, otherNoteCenter, containerRect) {
            const noteRect = noteElement.getBoundingClientRect();
            
            // Note's own center, relative to the container
            const noteCenterX = noteRect.left - containerRect.left + noteRect.width / 2;
            const noteCenterY = noteRect.top - containerRect.top + noteRect.height / 2;

            // Relative coordinates of the note's bounding box edges
            const noteLeft = noteRect.left - containerRect.left;
            const noteRight = noteRect.right - containerRect.left;
            const noteTop = noteRect.top - containerRect.top;
            const noteBottom = noteRect.bottom - containerRect.top;

            const dx = otherNoteCenter.x - noteCenterX;
            const dy = otherNoteCenter.y - noteCenterY;

            if (dx === 0 && dy === 0) return { x: noteCenterX, y: noteCenterY }; // Should not happen if notes are distinct

            let t = Infinity;
            let edgePoints = [];

            // Check intersection with each of the 4 edges
            // Top edge (y = noteTop)
            if (dy !== 0) {
                const tTop = (noteTop - noteCenterY) / dy;
                if (tTop >= 0) {
                     const intersectX = noteCenterX + tTop * dx;
                    if (intersectX >= noteLeft && intersectX <= noteRight) {
                        edgePoints.push({ x: intersectX, y: noteTop, t: tTop });
                    }
                }
            }
            // Bottom edge (y = noteBottom)
            if (dy !== 0) {
                const tBottom = (noteBottom - noteCenterY) / dy;
                if (tBottom >= 0) {
                    const intersectX = noteCenterX + tBottom * dx;
                    if (intersectX >= noteLeft && intersectX <= noteRight) {
                        edgePoints.push({ x: intersectX, y: noteBottom, t: tBottom });
                    }
                }
            }
            // Left edge (x = noteLeft)
            if (dx !== 0) {
                const tLeft = (noteLeft - noteCenterX) / dx;
                if (tLeft >= 0) {
                    const intersectY = noteCenterY + tLeft * dy;
                    if (intersectY >= noteTop && intersectY <= noteBottom) {
                        edgePoints.push({ x: noteLeft, y: intersectY, t: tLeft });
                    }
                }
            }
            // Right edge (x = noteRight)
            if (dx !== 0) {
                const tRight = (noteRight - noteCenterX) / dx;
                if (tRight >= 0) {
                    const intersectY = noteCenterY + tRight * dy;
                    if (intersectY >= noteTop && intersectY <= noteBottom) {
                        edgePoints.push({ x: noteRight, y: intersectY, t: tRight });
                    }
                }
            }
            
            // Filter for intersections that are "towards" the other note (0 < t <= 1 range approx for segment)
            // More robustly, pick the point with the smallest positive 't'
            // For a line originating from inside the rectangle, we are looking for the smallest positive t.
            edgePoints = edgePoints.filter(p => p.t > 1e-6); // Filter out points at or very near the center, use small epsilon

            if (edgePoints.length === 0) {
                 // This might happen if the other note's center is inside this note, or math error.
                 // Fallback to center of current note, or handle as error.
                 // console.warn("No valid intersection point found for note:", noteElement.id, "to point:", otherNoteCenter);
                 return { x: noteCenterX, y: noteCenterY }; // Fallback to center
            }

            // Sort by t to find the closest intersection point on the path towards the other note
            edgePoints.sort((a, b) => a.t - b.t);
            
            return { x: edgePoints[0].x, y: edgePoints[0].y };
        }

        function removeConnectionLine(connectionId) {
            if (!connectionsCanvas) return;
            const line = document.getElementById(`line-${connectionId}`);
            if (line) {
                connectionsCanvas.removeChild(line);
            }
        }

        function updateConnectionLinesForNote(noteId) {
            if (!connectionsCanvas) return;
            noteConnections.forEach(conn => {
                if (conn.sourceNoteId == noteId || conn.targetNoteId == noteId) {
                    drawConnection(conn); // Re-draw/update the specific connection
                }
            });
        }
        
        function redrawAllConnections() {
            if (!connectionsCanvas) return;
            // Clear existing lines (simple way, could be optimized)
            // while (connectionsCanvas.firstChild) {
            //     connectionsCanvas.removeChild(connectionsCanvas.firstChild);
            // }
            // Re-draw all
            noteConnections.forEach(conn => {
                drawConnection(conn);
            });
        }
        // Call redrawAllConnections on window resize or other layout changes if necessary
        // window.addEventListener('resize', redrawAllConnections);

        // --- Connect Mode UI Functions ---
        function setupConnectModeButton() {
            const connectModeBtn = document.getElementById('toggleConnectModeBtn');
            if (connectModeBtn) {
                connectModeBtn.addEventListener('click', () => {
                    isConnectMode = !isConnectMode;
                    if (isConnectMode) {
                        connectModeBtn.textContent = 'Cancel Connecting';
                        connectModeBtn.style.backgroundColor = '#dc3545'; // Red color for cancel
                        // Optionally, indicate connect mode visually (e.g., change cursor)
                        document.body.style.cursor = 'crosshair'; 
                    } else {
                        connectModeBtn.textContent = 'Connect Notes';
                        connectModeBtn.style.backgroundColor = '#6c757d'; // Default color
                        if (firstNoteSelectedForConnection) {
                            document.getElementById(firstNoteSelectedForConnection)?.classList.remove('selected-for-connection');
                        }
                        firstNoteSelectedForConnection = null;
                        document.body.style.cursor = 'default';
                    }
                });
            }
        }

        function handleNoteClickForConnection(noteId) {
            if (!isConnectMode) return;

            const noteElement = document.getElementById(noteId);
            if (!noteElement) return;

            if (!firstNoteSelectedForConnection) {
                // This is the first note selected
                firstNoteSelectedForConnection = noteId;
                noteElement.classList.add('selected-for-connection');
                console.log(`First note selected for connection: ${noteId}`);
            } else {
                // This is the second note selected
                if (firstNoteSelectedForConnection == noteId) {
                    // Clicked the same note again - deselect it or do nothing
                    console.log('Clicked the same note again. Deselecting.');
                    noteElement.classList.remove('selected-for-connection');
                    firstNoteSelectedForConnection = null;
                    return;
                }

                console.log(`Second note selected: ${noteId}. Creating connection between ${firstNoteSelectedForConnection} and ${noteId}`);
                connection.invoke("ConnectNotes", firstNoteSelectedForConnection, noteId);
                
                // Reset connect mode after attempting to connect
                document.getElementById(firstNoteSelectedForConnection)?.classList.remove('selected-for-connection');
                isConnectMode = false;
                firstNoteSelectedForConnection = null;
                const connectModeBtn = document.getElementById('toggleConnectModeBtn');
                if (connectModeBtn) {
                    connectModeBtn.textContent = 'Connect Notes';
                    connectModeBtn.style.backgroundColor = '#6c757d';
                }
                document.body.style.cursor = 'default';
            }
        }
    </script>
}
